# Install and configure Docker.
#
# The admin group *must* only contain trusted users (e.g. staff), as Docker
# containers can be used to compromise the host in many scenarios (e.g.
# mounting local filesystems, messing with network interfaces, more readily
# exploiting kernel bugs, etc.).
#
# Containers are helpful for testing things. For example:
#   docker run -ti debian:stretch bash
#
class ocf::packages::docker($admin_group = undef,
                            $autoclean = true,
                            $image_max_age = '24h',
                            $prune_volumes = true,
                            $kubernetes = false) {
  class { 'ocf::packages::docker::apt':
    stage => first,
  }

  if $kubernetes {
    $docker_kube_version = lookup('kubernetes::docker_version')

    # Kubernetes is specific about which versions of docker it will
    # work reliably with.
    package {
      'docker-ce':
        ensure => $docker_kube_version;
    } ->
    apt::pin { 'docker-ce':
      ensure   => present,
      packages => ['docker-ce'],
      priority => 1001,
      version  => $docker_kube_version;
    }
  } else {
    package {
      ['aufs-dkms', 'aufs-tools']:
        ensure => purged;
    }

    # Don't install AUFS stuff
    ocf::repackage {
      'docker-ce':
        recommends => false,
    }
  }

  exec { 'docker-socket-update':
    command     => 'systemctl restart docker.socket',
    refreshonly => true,
    require     => Exec['systemd-reload'],  # which is triggered by ocf::systemd::override
  }

  if $admin_group != undef {
    ocf::systemd::override { 'set-docker-socket-group':
      unit    => 'docker.socket',
      content => "[Socket]\nSocketGroup=${admin_group}\n",
      require => Package['docker-ce'],
      notify  => Exec['docker-socket-update'];
    }

    # Make sure that the docker socket only starts after networking is up so it
    # can set the correct SocketGroup, otherwise it might not be able to
    # contact LDAP to set the correct owning group and docker will fail to
    # start entirely on boot.
    ocf::systemd::override { 'docker-socket-wait-for-networking':
      unit    => 'docker.socket',
      content => "[Unit]\nAfter=network-online.target\nWants=network-online.target\n",
      require => Package['docker-ce'],
      notify  => Exec['docker-socket-update'];
    }
  }

  if $autoclean {
    cron {
      'clean-old-docker-containers':
        # We don't use docker container prune here because that deletes
        # containers by creation time rather than exit time
        command => "docker ps -a --filter status=exited | grep -E 'Exited \\([0-9]+\\) [0-9]+ (days|weeks?|months?|years?) ago' | awk '{print \$1}' | chronic xargs -r docker rm",
        hour    => 1,
        minute  => 3;

      'clean-old-created-docker-containers':
        # We don't use docker container prune here because we can't filter
        # by container state
        command => "docker ps -a --filter status=created | grep -E '(days|weeks?|months?|years?) ago' | awk '{print \$1}' | chronic xargs -r docker rm",
        hour    => 1,
        minute  => 5;

      'clean-docker-images':
        command => "chronic docker image prune -a --filter until=${image_max_age} -f",
        hour    => 1,
        minute  => 17;
    }

    # We don't currently use Docker volumes in OCF workflows. However,
    # volumes sometimes get spontaneously generated by launching containers
    # from certain images. Thus, we prune away any such volumes here.
    $prune_volumes_ensure = $prune_volumes ? {
      true  => present,
      false => absent,
    }
    cron {
      'clean-docker-volumes':
        ensure  => $prune_volumes_ensure,
        command => 'chronic docker volume prune -f',
        hour    => 1,
        minute  => 30;
    }
  }
}
